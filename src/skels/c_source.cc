/*
 * File automatically generated by
 * gengen 1.1 by Lorenzo Bettini 
 * http://www.gnu.org/software/gengen
 */

#include "c_source.h"

void
c_source_gen_class::generate_c_source(ostream &stream, unsigned int indent)
{
  string indent_str (indent, ' ');
  indent = 0;

  stream << "/*";
  stream << "\n";
  stream << indent_str;
  stream << "  File autogenerated by gengetopt ";
  generate_string (generator_version, stream, indent + indent_str.length ());
  stream << "\n";
  stream << indent_str;
  stream << "  generated with the following command:";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (command_line, stream, indent + indent_str.length ());
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  The developers of gengetopt consider the fixed text that goes in all";
  stream << "\n";
  stream << indent_str;
  stream << "  gengetopt output files to be in the public domain:";
  stream << "\n";
  stream << indent_str;
  stream << "  we make no copyright claims on it.";
  stream << "\n";
  stream << indent_str;
  stream << "*/";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "/* If we use autoconf.  */";
  stream << "\n";
  stream << indent_str;
  stream << "#ifdef HAVE_CONFIG_H";
  stream << "\n";
  stream << indent_str;
  stream << "#include \"config.h\"";
  stream << "\n";
  stream << indent_str;
  stream << "#endif";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "#include <stdio.h>";
  stream << "\n";
  stream << indent_str;
  stream << "#include <stdlib.h>";
  stream << "\n";
  stream << indent_str;
  stream << "#include <string.h>";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  if (( ! include_getopt ))
    {
      stream << "#include \"getopt.h\"";
      stream << "\n";
      stream << indent_str;
    }
  stream << "\n";
  stream << indent_str;
  stream << "#include \"";
  generate_string (source_name, stream, indent + indent_str.length ());
  stream << ".";
  generate_string (header_file_ext, stream, indent + indent_str.length ());
  stream << "\"";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "const char *";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_purpose = \"";
  generate_string (purpose, stream, indent + indent_str.length ());
  stream << "\";";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "const char *";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_usage = \"Usage:";
  if (no_package)
    {
      stream << " \" ";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << " \"";
    }
  stream << " ";
  generate_string (usage_string, stream, indent + indent_str.length ());
  stream << "\";";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "const char *";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_description = \"";
  generate_string (description, stream, indent + indent_str.length ());
  stream << "\";";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "const char *";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_help[] = {";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  if (help_option_print.size () > 0)
    generate_string (help_option_print, stream, indent + indent_str.length ());
  else
    generate_help_option_print (stream, indent + indent_str.length ());
  stream << "  0";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "};";
  stream << "\n";
  stream << indent_str;
  if (has_hidden)
    {
      stream << "const char *";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << "_full_help[] = {";
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      if (full_help_option_print.size () > 0)
        generate_string (full_help_option_print, stream, indent + indent_str.length ());
      else
        generate_full_help_option_print (stream, indent + indent_str.length ());
      stream << "  0";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "};";
      stream << "\n";
      stream << indent_str;
    }
  stream << "\n";
  stream << indent_str;
  stream << "static";
  stream << "\n";
  stream << indent_str;
  stream << "void clear_given (struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info);";
  stream << "\n";
  stream << indent_str;
  stream << "static";
  stream << "\n";
  stream << indent_str;
  stream << "void clear_args (struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "static int";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_internal (int argc, char * const *argv, struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info,";
  stream << "\n";
  stream << indent_str;
  stream << "                        struct ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_params *params, const char *additional_error);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  if (check_required_options)
    {
      stream << "static int";
      stream << "\n";
      stream << indent_str;
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_required2 (struct ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << " *args_info, const char *prog_name, const char *additional_error);";
      stream << "\n";
      stream << indent_str;
    }
  if (cmd_list)
    {
      stream << "struct line_list";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  char * string_arg;";
      stream << "\n";
      stream << indent_str;
      stream << "  struct line_list * next;";
      stream << "\n";
      stream << indent_str;
      stream << "};";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "static struct line_list *cmd_line_list = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "static struct line_list *cmd_line_list_tmp = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "static void";
      stream << "\n";
      stream << indent_str;
      stream << "free_cmd_list(void)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  /* free the list of a previous call */";
      stream << "\n";
      stream << indent_str;
      stream << "  if (cmd_line_list)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      while (cmd_line_list) {";
      stream << "\n";
      stream << indent_str;
      stream << "        cmd_line_list_tmp = cmd_line_list;";
      stream << "\n";
      stream << indent_str;
      stream << "        cmd_line_list = cmd_line_list->next;";
      stream << "\n";
      stream << indent_str;
      stream << "        free (cmd_line_list_tmp->string_arg);";
      stream << "\n";
      stream << indent_str;
      stream << "        free (cmd_line_list_tmp);";
      stream << "\n";
      stream << indent_str;
      stream << "      }";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  stream << "\n";
  stream << indent_str;
  if (struct_def.size () > 0)
    generate_string (struct_def, stream, indent + indent_str.length ());
  else
    generate_struct_def (stream, indent + indent_str.length ());
  stream << indent_str;
  if (option_values.size () > 0)
    generate_string (option_values, stream, indent + indent_str.length ());
  else
    generate_option_values (stream, indent + indent_str.length ());
  stream << indent_str;
  if (do_generate_strdup)
    {
      stream << "static char *";
      stream << "\n";
      stream << indent_str;
      stream << "gengetopt_strdup (const char *s);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  stream << "static";
  stream << "\n";
  stream << indent_str;
  stream << "void clear_given (struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  if (given_init.size () > 0)
    generate_string (given_init, stream, indent + indent_str.length ());
  else
    generate_given_init (stream, indent + indent_str.length ());
  indent = 0;
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "static";
  stream << "\n";
  stream << indent_str;
  stream << "void clear_args (struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  if (clear_arg.size () > 0)
    generate_string (clear_arg, stream, indent + indent_str.length ());
  else
    generate_clear_arg (stream, indent + indent_str.length ());
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "static";
  stream << "\n";
  stream << indent_str;
  stream << "void init_args_info(struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  if (init_args_info.size () > 0)
    generate_string (init_args_info, stream, indent + indent_str.length ());
  else
    generate_init_args_info (stream, indent + indent_str.length ());
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "void";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_print_version (void)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  printf (\"%s %s\\n\", ";
  generate_string (package_var_name, stream, indent + indent_str.length ());
  stream << ", ";
  generate_string (version_var_name, stream, indent + indent_str.length ());
  stream << ");";
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "void";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_print_help (void)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  int i = 0;";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_print_version ();";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  if (strlen(";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_purpose) > 0)";
  stream << "\n";
  stream << indent_str;
  stream << "    printf(\"\\n%s\\n\", ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_purpose);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  printf(\"\\n%s\\n\\n\", ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_usage);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  if (strlen(";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_description) > 0)";
  stream << "\n";
  stream << indent_str;
  stream << "    printf(\"%s\\n\", ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_description);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  while (";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_help[i])";
  stream << "\n";
  stream << indent_str;
  stream << "    printf(\"%s\\n\", ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << "_help[i++]);";
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  if (has_hidden)
    {
      stream << "void";
      stream << "\n";
      stream << indent_str;
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_print_full_help (void)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  int i = 0;";
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_print_version ();";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (strlen(";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << "_purpose) > 0)";
      stream << "\n";
      stream << indent_str;
      stream << "    printf(\"\\n%s\\n\", ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << "_purpose);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  printf(\"\\n%s\\n\\n\", ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << "_usage);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (strlen(";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << "_description) > 0)";
      stream << "\n";
      stream << indent_str;
      stream << "    printf(\"%s\\n\", ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << "_description);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  while (";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << "_full_help[i])";
      stream << "\n";
      stream << indent_str;
      stream << "    printf(\"%s\\n\", ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << "_full_help[i++]);";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  stream << "void";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_init (struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  clear_given (args_info);";
  stream << "\n";
  stream << indent_str;
  stream << "  clear_args (args_info);";
  stream << "\n";
  stream << indent_str;
  stream << "  init_args_info (args_info);";
  stream << "\n";
  stream << indent_str;
  if (handle_unamed)
    {
      stream << "\n";
      stream << indent_str;
      stream << "  args_info->inputs = NULL;";
      stream << "\n";
      stream << indent_str;
      stream << "  args_info->inputs_num = 0;";
      stream << "\n";
      stream << indent_str;
    }
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "struct ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_params *";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_params_init()";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  struct ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_params *params = ";
  stream << "\n";
  stream << indent_str;
  stream << "    (struct ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_params *)malloc(sizeof(struct ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_params));";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  if (params)";
  stream << "\n";
  stream << indent_str;
  stream << "    { ";
  stream << "\n";
  stream << indent_str;
  stream << "      params->override = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "      params->initialize = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "      params->check_required = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "      params->check_ambiguity = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "    }";
  stream << "\n";
  stream << indent_str;
  indent = 4;
  stream << "    ";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "  return params;";
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "static void";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_release (struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  if (free.size () > 0)
    generate_string (free, stream, indent + indent_str.length ());
  else
    generate_free (stream, indent + indent_str.length ());
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "  clear_given (args_info);";
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "int";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_file_save(const char *filename, struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  FILE *outfile;";
  stream << "\n";
  stream << indent_str;
  stream << "  int i = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  outfile = fopen(filename, \"w\");";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  if (!outfile)";
  stream << "\n";
  stream << indent_str;
  stream << "    {";
  stream << "\n";
  stream << indent_str;
  stream << "      fprintf (stderr, \"%s: cannot open file for writing: %s\\n\", ";
  generate_string (package_var_name, stream, indent + indent_str.length ());
  stream << ", filename);";
  stream << "\n";
  stream << indent_str;
  stream << "      return EXIT_FAILURE;";
  stream << "\n";
  stream << indent_str;
  stream << "    }";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  if (file_save_loop.size () > 0)
    generate_string (file_save_loop, stream, indent + indent_str.length ());
  else
    generate_file_save_loop (stream, indent + indent_str.length ());
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "  fclose (outfile);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  i = EXIT_SUCCESS;";
  stream << "\n";
  stream << indent_str;
  stream << "  return i;";
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "void";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_free (struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_release (args_info);";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  if (check_possible_values)
    {
      stream << "/*";
      stream << "\n";
      stream << indent_str;
      stream << " * Returns:";
      stream << "\n";
      stream << indent_str;
      stream << " * - the index of the matched value";
      stream << "\n";
      stream << indent_str;
      stream << " * - -1 if no argument has been specified";
      stream << "\n";
      stream << indent_str;
      stream << " * - -2 if more than one value has matched";
      stream << "\n";
      stream << indent_str;
      stream << " */";
      stream << "\n";
      stream << indent_str;
      stream << "static int";
      stream << "\n";
      stream << indent_str;
      stream << "check_possible_values(const char *val, char *values[])";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  int i, found, last;";
      stream << "\n";
      stream << indent_str;
      stream << "  size_t len;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (!val)   /* otherwise strlen() crashes below */";
      stream << "\n";
      stream << indent_str;
      stream << "    return -1; /* -1 means no argument for the option */";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  found = last = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  for (i = 0, len = strlen(val); values[i]; ++i)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      if (strncmp(val, values[i], len) == 0)";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          ++found;";
      stream << "\n";
      stream << indent_str;
      stream << "          last = i;";
      stream << "\n";
      stream << indent_str;
      stream << "          if (strlen(values[i]) == len)";
      stream << "\n";
      stream << indent_str;
      stream << "            return i; /* exact macth no need to check more */";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (found == 1) /* one match: OK */";
      stream << "\n";
      stream << indent_str;
      stream << "    return last;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  return (found ? -2 : -1); /* return many values are matched */";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  stream << "\n";
  stream << indent_str;
  if (do_generate_strdup)
    {
      stream << "/* gengetopt_strdup() */";
      stream << "\n";
      stream << indent_str;
      stream << "/* strdup.c replacement of strdup, which is not standard */";
      stream << "\n";
      stream << indent_str;
      stream << "char *";
      stream << "\n";
      stream << indent_str;
      stream << "gengetopt_strdup (const char *s)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  char *result = NULL;";
      stream << "\n";
      stream << indent_str;
      stream << "  if (!s)";
      stream << "\n";
      stream << indent_str;
      stream << "    return result;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  result = (char*)malloc(strlen(s) + 1);";
      stream << "\n";
      stream << indent_str;
      stream << "  if (result == (char*)0)";
      stream << "\n";
      stream << indent_str;
      stream << "    return (char*)0;";
      stream << "\n";
      stream << indent_str;
      stream << "  strcpy(result, s);";
      stream << "\n";
      stream << indent_str;
      stream << "  return result;";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  if (multiple_token_functions)
    {
      stream << "static char *";
      stream << "\n";
      stream << indent_str;
      stream << "get_multiple_arg_token(const char *arg)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  char *tok, *ret;";
      stream << "\n";
      stream << indent_str;
      stream << "  size_t len, num_of_escape;";
      stream << "\n";
      stream << indent_str;
      stream << "  int i, j;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (!arg)";
      stream << "\n";
      stream << indent_str;
      stream << "    return NULL;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  tok = strchr (arg, ',');";
      stream << "\n";
      stream << indent_str;
      stream << "  num_of_escape = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  /* make sure it is not escaped */";
      stream << "\n";
      stream << indent_str;
      stream << "  while (tok)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      if (*(tok-1) == '\\\\')";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          /* find the next one */";
      stream << "\n";
      stream << indent_str;
      stream << "          tok = strchr (tok+1, ',');";
      stream << "\n";
      stream << indent_str;
      stream << "          ++num_of_escape;";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "      else";
      stream << "\n";
      stream << indent_str;
      stream << "        break;";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (tok)";
      stream << "\n";
      stream << indent_str;
      stream << "    len = (size_t)(tok - arg + 1);";
      stream << "\n";
      stream << indent_str;
      stream << "  else";
      stream << "\n";
      stream << indent_str;
      stream << "    len = strlen (arg) + 1;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  len -= num_of_escape;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  ret = (char *) malloc (len);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  i = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "  j = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "  while (arg[i] && (j < len-1))";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      if (arg[i] == '\\\\' && ";
      stream << "\n";
      stream << indent_str;
      stream << "	  arg[ i + 1 ] && ";
      stream << "\n";
      stream << indent_str;
      stream << "	  arg[ i + 1 ] == ',')";
      stream << "\n";
      stream << indent_str;
      stream << "        ++i;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      ret[j++] = arg[i++];";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  ret[len-1] = '\\0';";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  return ret;";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "static char *";
      stream << "\n";
      stream << indent_str;
      stream << "get_multiple_arg_token_next(const char *arg)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  char *tok;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (!arg)";
      stream << "\n";
      stream << indent_str;
      stream << "    return NULL;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  tok = strchr (arg, ',');";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  /* make sure it is not escaped */";
      stream << "\n";
      stream << indent_str;
      stream << "  while (tok)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      if (*(tok-1) == '\\\\')";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          /* find the next one */";
      stream << "\n";
      stream << indent_str;
      stream << "          tok = strchr (tok+1, ',');";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "      else";
      stream << "\n";
      stream << indent_str;
      stream << "        break;";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (! tok || strlen(tok) == 1)";
      stream << "\n";
      stream << indent_str;
      stream << "    return 0;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  return tok+1;";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  if (multiple_options)
    {
      stream << "static int";
      stream << "\n";
      stream << indent_str;
      stream << "check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, int min, int max, const char *option_desc);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "int";
      stream << "\n";
      stream << indent_str;
      stream << "check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, int min, int max, const char *option_desc)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  int error = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (option_given && ! (min < 0 && max < 0))";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      if (min >= 0 && max >= 0)";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          if (min == max)";
      stream << "\n";
      stream << indent_str;
      stream << "            {";
      stream << "\n";
      stream << indent_str;
      stream << "              /* specific occurrences */";
      stream << "\n";
      stream << indent_str;
      stream << "              if (option_given != min)";
      stream << "\n";
      stream << indent_str;
      stream << "                {";
      stream << "\n";
      stream << indent_str;
      stream << "                  fprintf (stderr, \"%s: %s option occurrences must be %d\\n\",";
      stream << "\n";
      stream << indent_str;
      stream << "                    prog_name, option_desc, min);";
      stream << "\n";
      stream << indent_str;
      stream << "                  error = 1;";
      stream << "\n";
      stream << indent_str;
      stream << "                }";
      stream << "\n";
      stream << indent_str;
      stream << "            }";
      stream << "\n";
      stream << indent_str;
      stream << "          else if (option_given < min";
      stream << "\n";
      stream << indent_str;
      stream << "              || option_given > max)";
      stream << "\n";
      stream << indent_str;
      stream << "            {";
      stream << "\n";
      stream << indent_str;
      stream << "              /* range occurrences */";
      stream << "\n";
      stream << indent_str;
      stream << "              fprintf (stderr, \"%s: %s option occurrences must be between %d and %d\\n\",";
      stream << "\n";
      stream << indent_str;
      stream << "                prog_name, option_desc, min, max);";
      stream << "\n";
      stream << indent_str;
      stream << "              error = 1;";
      stream << "\n";
      stream << indent_str;
      stream << "            }";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "      else if (min >= 0)";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          /* at least check */";
      stream << "\n";
      stream << indent_str;
      stream << "          if (option_given < min)";
      stream << "\n";
      stream << indent_str;
      stream << "            {";
      stream << "\n";
      stream << indent_str;
      stream << "              fprintf (stderr, \"%s: %s option occurrences must be at least %d\\n\",";
      stream << "\n";
      stream << indent_str;
      stream << "                prog_name, option_desc, min);";
      stream << "\n";
      stream << indent_str;
      stream << "              error = 1;";
      stream << "\n";
      stream << indent_str;
      stream << "            }";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "      else if (max >= 0)";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          /* at most check */";
      stream << "\n";
      stream << indent_str;
      stream << "          if (option_given > max)";
      stream << "\n";
      stream << indent_str;
      stream << "            {";
      stream << "\n";
      stream << indent_str;
      stream << "              fprintf (stderr, \"%s: %s option occurrences must be at most %d\\n\",";
      stream << "\n";
      stream << indent_str;
      stream << "                prog_name, option_desc, max);";
      stream << "\n";
      stream << indent_str;
      stream << "              error = 1;";
      stream << "\n";
      stream << indent_str;
      stream << "            }";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      indent = 4;
      stream << "    ";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "  return error;";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
    }
  if (reset_groups.size () > 0)
    generate_string (reset_groups, stream, indent + indent_str.length ());
  else
    generate_reset_groups (stream, indent + indent_str.length ());
  stream << indent_str;
  stream << "int";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << " (int argc, char * const *argv, struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  return ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "2 (argc, argv, args_info, 0, 1, 1);";
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "int";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_ext (int argc, char * const *argv, struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info,";
  stream << "\n";
  stream << indent_str;
  stream << "                   struct ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_params *params)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  int result;";
  stream << "\n";
  stream << indent_str;
  stream << "  result = ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_internal (argc, argv, args_info, params, NULL);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (final_exit, stream, indent + indent_str.length ());
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "int";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "2 (int argc, char * const *argv, struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info, int override, int initialize, int check_required)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  int result;";
  stream << "\n";
  stream << indent_str;
  stream << "  struct ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_params params;";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "  params.override = override;";
  stream << "\n";
  stream << indent_str;
  stream << "  params.initialize = initialize;";
  stream << "\n";
  stream << indent_str;
  stream << "  params.check_required = check_required;";
  stream << "\n";
  stream << indent_str;
  stream << "  params.check_ambiguity = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  result = ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_internal (argc, argv, args_info, &params, NULL);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (final_exit, stream, indent + indent_str.length ());
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "int";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_required (struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info, const char *prog_name)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  if (check_required_options)
    {
      stream << "  int result = EXIT_SUCCESS;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_required2(args_info, prog_name, NULL) > 0)";
      stream << "\n";
      stream << indent_str;
      stream << "    result = EXIT_FAILURE;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      generate_string (final_exit, stream, indent + indent_str.length ());
      indent = 0;
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      stream << "  return EXIT_SUCCESS;";
      stream << "\n";
      stream << indent_str;
    }
  stream << "}";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  if (check_required_options)
    {
      stream << "int";
      stream << "\n";
      stream << indent_str;
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_required2 (struct ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << " *args_info, const char *prog_name, const char *additional_error)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  int error = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  /* checks for required options */";
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      if (handle_required.size () > 0)
        generate_string (handle_required, stream, indent + indent_str.length ());
      else
        generate_handle_required (stream, indent + indent_str.length ());
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "  /* checks for dependences among options */";
      stream << "\n";
      stream << indent_str;
      indent = 2;
      if (handle_dependencies.size () > 0)
        generate_string (handle_dependencies, stream, indent + indent_str.length ());
      else
        generate_handle_dependencies (stream, indent + indent_str.length ());
      indent = 0;
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  return error;";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  if (include_getopt)
    {
      if (custom_getopt.size () > 0)
        generate_string (custom_getopt, stream, indent + indent_str.length ());
      else
        generate_custom_getopt (stream, indent + indent_str.length ());
      stream << "\n";
      stream << indent_str;
    }
  stream << "int";
  stream << "\n";
  stream << indent_str;
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_internal (int argc, char * const *argv, struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info,";
  stream << "\n";
  stream << indent_str;
  stream << "                        struct ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_params *params, const char *additional_error)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  int c;	/* Character of the parsed option.  */";
  stream << "\n";
  stream << indent_str;
  if (multiple_token_vars)
    {
      stream << "  char *multi_token, *multi_next; /* for multiple options */";
      stream << "\n";
      stream << indent_str;
    }
  stream << "\n";
  stream << indent_str;
  indent = 2;
  if (list_def.size () > 0)
    generate_string (list_def, stream, indent + indent_str.length ());
  else
    generate_list_def (stream, indent + indent_str.length ());
  indent = 0;
  stream << indent_str;
  stream << "  int error = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "  struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " local_args_info;";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "  int override;";
  stream << "\n";
  stream << indent_str;
  stream << "  int initialize;";
  stream << "\n";
  stream << indent_str;
  stream << "  int check_required;";
  stream << "\n";
  stream << indent_str;
  stream << "  int check_ambiguity;";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "  override = params->override;";
  stream << "\n";
  stream << indent_str;
  stream << "  initialize = params->initialize;";
  stream << "\n";
  stream << indent_str;
  stream << "  check_required = params->check_required;";
  stream << "\n";
  stream << indent_str;
  stream << "  check_ambiguity = params->check_ambiguity;";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  if (initialize)";
  stream << "\n";
  stream << indent_str;
  indent = 4;
  stream << "    ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_init (args_info);";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_init (&local_args_info);";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  optarg = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "  optind = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "  opterr = 1;";
  stream << "\n";
  stream << indent_str;
  stream << "  optopt = '?';";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  while (1)";
  stream << "\n";
  stream << indent_str;
  stream << "    {";
  stream << "\n";
  stream << indent_str;
  if (check_possible_values)
    {
      stream << "      int found = 0;";
      stream << "\n";
      stream << indent_str;
    }
  stream << "      int option_index = 0;";
  stream << "\n";
  stream << indent_str;
  stream << "      char *stop_char;";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "      static struct option long_options[] = {";
  stream << "\n";
  stream << indent_str;
  indent = 8;
  if (long_option_struct.size () > 0)
    generate_string (long_option_struct, stream, indent + indent_str.length ());
  else
    generate_long_option_struct (stream, indent + indent_str.length ());
  indent = 0;
  stream << indent_str;
  stream << "        { NULL,	0, NULL, 0 }";
  stream << "\n";
  stream << indent_str;
  stream << "      };";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "      stop_char = 0;";
  stream << "\n";
  stream << indent_str;
  if (include_getopt)
    {
      stream << "      custom_optarg = optarg;";
      stream << "\n";
      stream << indent_str;
      stream << "      custom_optind = optind;";
      stream << "\n";
      stream << indent_str;
      stream << "      custom_opterr = opterr;";
      stream << "\n";
      stream << indent_str;
      stream << "      custom_optopt = optopt;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      c = custom_getopt_long (argc, argv, \"";
      generate_string (getopt_string, stream, indent + indent_str.length ());
      stream << "\", long_options, &option_index);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      optarg = custom_optarg;";
      stream << "\n";
      stream << indent_str;
      stream << "      optind = custom_optind;";
      stream << "\n";
      stream << indent_str;
      stream << "      opterr = custom_opterr;";
      stream << "\n";
      stream << indent_str;
      stream << "      optopt = custom_optopt;";
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      stream << "      c = getopt_long (argc, argv, \"";
      generate_string (getopt_string, stream, indent + indent_str.length ());
      stream << "\", long_options, &option_index);";
      stream << "\n";
      stream << indent_str;
    }
  stream << "\n";
  stream << indent_str;
  stream << "      if (c == -1) break;	/* Exit from `while (1)' loop.  */";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "      switch (c)";
  stream << "\n";
  stream << indent_str;
  stream << "        {";
  stream << "\n";
  stream << indent_str;
  indent = 8;
  if (handle_option.size () > 0)
    generate_string (handle_option, stream, indent + indent_str.length ());
  else
    generate_handle_option (stream, indent + indent_str.length ());
  indent = 0;
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "        case 0:	/* Long option with no short option */";
  stream << "\n";
  stream << indent_str;
  indent = 10;
  if (handle_no_short_option.size () > 0)
    generate_string (handle_no_short_option, stream, indent + indent_str.length ());
  else
    generate_handle_no_short_option (stream, indent + indent_str.length ());
  indent = 0;
  stream << indent_str;
  stream << "        case '?':	/* Invalid option.  */";
  stream << "\n";
  stream << indent_str;
  stream << "          /* `getopt_long' already printed an error message.  */";
  stream << "\n";
  stream << indent_str;
  stream << "          goto failure;";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "        default:	/* bug: option not considered.  */";
  stream << "\n";
  stream << indent_str;
  stream << "          fprintf (stderr, \"%s: option unknown: %c%s\\n\", ";
  generate_string (package_var_name, stream, indent + indent_str.length ());
  stream << ", c, (additional_error ? additional_error : \"\"));";
  stream << "\n";
  stream << indent_str;
  stream << "          abort ();";
  stream << "\n";
  stream << indent_str;
  stream << "        } /* switch */";
  stream << "\n";
  stream << indent_str;
  stream << "    } /* while */";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  indent = 2;
  if (handle_group.size () > 0)
    generate_string (handle_group, stream, indent + indent_str.length ());
  else
    generate_handle_group (stream, indent + indent_str.length ());
  indent = 0;
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  indent = 2;
  if (multiple_fill_array.size () > 0)
    generate_string (multiple_fill_array, stream, indent + indent_str.length ());
  else
    generate_multiple_fill_array (stream, indent + indent_str.length ());
  indent = 0;
  stream << indent_str;
  indent = 2;
  if (update_multiple_given.size () > 0)
    generate_string (update_multiple_given, stream, indent + indent_str.length ());
  else
    generate_update_multiple_given (stream, indent + indent_str.length ());
  indent = 0;
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  if (check_required_options)
    {
      stream << "  if (check_required)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      error += ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_required2 (args_info, argv[0], additional_error);";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
    }
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_release (&local_args_info);";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "  if ( error )";
  stream << "\n";
  stream << indent_str;
  stream << "    return (EXIT_FAILURE);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  if (handle_unamed)
    {
      stream << "  if (optind < argc)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      int i = 0 ;";
      stream << "\n";
      stream << indent_str;
      stream << "      int found_prog_name = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "      /* whether program name, i.e., argv[0], is in the remaining args";
      stream << "\n";
      stream << indent_str;
      stream << "         (this may happen with some implementations of getopt,";
      stream << "\n";
      stream << indent_str;
      stream << "          but surely not with the one included by gengetopt) */";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      if (include_getopt)
        {
          
      
        }
      else
        {
          stream << "      i = optind;";
          stream << "\n";
          stream << indent_str;
          stream << "      while (i < argc)";
          stream << "\n";
          stream << indent_str;
          stream << "        if (argv[i++] == argv[0]) {";
          stream << "\n";
          stream << indent_str;
          stream << "          found_prog_name = 1;";
          stream << "\n";
          stream << indent_str;
          stream << "          break;";
          stream << "\n";
          stream << indent_str;
          stream << "        }";
          stream << "\n";
          stream << indent_str;
          stream << "      i = 0;";
          stream << "\n";
          stream << indent_str;
        }
      stream << "\n";
      stream << indent_str;
      stream << "      args_info->inputs_num = argc - optind - found_prog_name;";
      stream << "\n";
      stream << indent_str;
      stream << "      args_info->inputs =";
      stream << "\n";
      stream << indent_str;
      stream << "        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;";
      stream << "\n";
      stream << indent_str;
      stream << "      while (optind < argc)";
      stream << "\n";
      stream << indent_str;
      if (include_getopt)
        {
          stream << "        args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind++]) ;";
          stream << "\n";
          stream << indent_str;
        }
      else
        {
          stream << "        if (argv[optind++] != argv[0])";
          stream << "\n";
          stream << indent_str;
          stream << "          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;";
          stream << "\n";
          stream << indent_str;
        }
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  stream << "  return 0;";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "failure:";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  if (list_free.size () > 0)
    generate_string (list_free, stream, indent + indent_str.length ());
  else
    generate_list_free (stream, indent + indent_str.length ());
  indent = 0;
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_release (&local_args_info);";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "  return (EXIT_FAILURE);";
  stream << "\n";
  stream << indent_str;
  stream << "}";
  stream << "\n";
  stream << indent_str;
  if (conf_parser)
    {
      stream << "\n";
      stream << indent_str;
      stream << "#ifndef CONFIG_FILE_LINE_SIZE";
      stream << "\n";
      stream << indent_str;
      stream << "#define CONFIG_FILE_LINE_SIZE 2048";
      stream << "\n";
      stream << indent_str;
      stream << "#endif";
      stream << "\n";
      stream << indent_str;
      stream << "#define ADDITIONAL_ERROR \" in configuration file \"";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "#define CONFIG_FILE_LINE_BUFFER_SIZE (CONFIG_FILE_LINE_SIZE+3)";
      stream << "\n";
      stream << indent_str;
      stream << "/* 3 is for \"--\" and \"=\" */";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "static int";
      stream << "\n";
      stream << indent_str;
      stream << "_";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_configfile (char * const filename, int *my_argc)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  FILE* file;";
      stream << "\n";
      stream << indent_str;
      stream << "  char my_argv[CONFIG_FILE_LINE_BUFFER_SIZE+1];";
      stream << "\n";
      stream << indent_str;
      stream << "  char linebuf[CONFIG_FILE_LINE_SIZE];";
      stream << "\n";
      stream << indent_str;
      stream << "  int line_num = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "  int result = 0, equal;";
      stream << "\n";
      stream << indent_str;
      stream << "  char *fopt, *farg;";
      stream << "\n";
      stream << indent_str;
      stream << "  char *str_index;";
      stream << "\n";
      stream << indent_str;
      stream << "  size_t len, next_token;";
      stream << "\n";
      stream << indent_str;
      stream << "  char delimiter;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if ((file = fopen(filename, \"r\")) == NULL)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      fprintf (stderr, \"%s: Error opening configuration file '%s'\\n\",";
      stream << "\n";
      stream << indent_str;
      indent = 15;
      stream << "               ";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ", filename);";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "      return EXIT_FAILURE;";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  while ((fgets(linebuf, CONFIG_FILE_LINE_SIZE, file)) != NULL)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      ++line_num;";
      stream << "\n";
      stream << indent_str;
      stream << "      my_argv[0] = '\\0';";
      stream << "\n";
      stream << indent_str;
      stream << "      len = strlen(linebuf);";
      stream << "\n";
      stream << indent_str;
      stream << "      if (len > (CONFIG_FILE_LINE_BUFFER_SIZE-1))";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          fprintf (stderr, \"%s:%s:%d: Line too long in configuration file\\n\",";
      stream << "\n";
      stream << indent_str;
      indent = 19;
      stream << "                   ";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ", filename, line_num);";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "          result = EXIT_FAILURE;";
      stream << "\n";
      stream << indent_str;
      stream << "          break;";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      /* find first non-whitespace character in the line */";
      stream << "\n";
      stream << indent_str;
      stream << "      next_token = strspn (linebuf, \" \\t\\r\\n\");";
      stream << "\n";
      stream << indent_str;
      stream << "      str_index  = linebuf + next_token;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      if ( str_index[0] == '\\0' || str_index[0] == '#')";
      stream << "\n";
      stream << indent_str;
      stream << "        continue; /* empty line or comment line is skipped */";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      fopt = str_index;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      /* truncate fopt at the end of the first non-valid character */";
      stream << "\n";
      stream << indent_str;
      stream << "      next_token = strcspn (fopt, \" \\t\\r\\n=\");";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      if (fopt[next_token] == '\\0') /* the line is over */";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          farg  = NULL;";
      stream << "\n";
      stream << indent_str;
      stream << "          equal = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "          goto noarg;";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      /* remember if equal sign is present */";
      stream << "\n";
      stream << indent_str;
      stream << "      equal = (fopt[next_token] == '=');";
      stream << "\n";
      stream << indent_str;
      stream << "      fopt[next_token++] = '\\0';";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      /* advance pointers to the next token after the end of fopt */";
      stream << "\n";
      stream << indent_str;
      stream << "      next_token += strspn (fopt + next_token, \" \\t\\r\\n\");";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      /* check for the presence of equal sign, and if so, skip it */";
      stream << "\n";
      stream << indent_str;
      stream << "      if ( !equal )";
      stream << "\n";
      stream << indent_str;
      stream << "        if ((equal = (fopt[next_token] == '=')))";
      stream << "\n";
      stream << indent_str;
      stream << "          {";
      stream << "\n";
      stream << indent_str;
      stream << "            next_token++;";
      stream << "\n";
      stream << indent_str;
      stream << "            next_token += strspn (fopt + next_token, \" \\t\\r\\n\");";
      stream << "\n";
      stream << indent_str;
      stream << "          }";
      stream << "\n";
      stream << indent_str;
      stream << "      str_index  += next_token;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      /* find argument */";
      stream << "\n";
      stream << indent_str;
      stream << "      farg = str_index;";
      stream << "\n";
      stream << indent_str;
      stream << "      if ( farg[0] == '\\\"' || farg[0] == '\\'' )";
      stream << "\n";
      stream << indent_str;
      stream << "        { /* quoted argument */";
      stream << "\n";
      stream << indent_str;
      stream << "          str_index = strchr (++farg, str_index[0] ); /* skip opening quote */";
      stream << "\n";
      stream << indent_str;
      stream << "          if (! str_index)";
      stream << "\n";
      stream << indent_str;
      stream << "            {";
      stream << "\n";
      stream << indent_str;
      stream << "              fprintf";
      stream << "\n";
      stream << indent_str;
      stream << "                (stderr,";
      stream << "\n";
      stream << indent_str;
      stream << "                 \"%s:%s:%d: unterminated string in configuration file\\n\",";
      stream << "\n";
      stream << indent_str;
      indent = 17;
      stream << "                 ";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ", filename, line_num);";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "              result = EXIT_FAILURE;";
      stream << "\n";
      stream << indent_str;
      stream << "              break;";
      stream << "\n";
      stream << indent_str;
      stream << "            }";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "      else";
      stream << "\n";
      stream << indent_str;
      stream << "        { /* read up the remaining part up to a delimiter */";
      stream << "\n";
      stream << indent_str;
      stream << "          next_token = strcspn (farg, \" \\t\\r\\n#\\'\\\"\");";
      stream << "\n";
      stream << indent_str;
      stream << "          str_index += next_token;";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      /* truncate farg at the delimiter and store it for further check */";
      stream << "\n";
      stream << indent_str;
      stream << "      delimiter = *str_index, *str_index++ = '\\0';";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      /* everything but comment is illegal at the end of line */";
      stream << "\n";
      stream << indent_str;
      stream << "      if (delimiter != '\\0' && delimiter != '#')";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          str_index += strspn(str_index, \" \\t\\r\\n\");";
      stream << "\n";
      stream << indent_str;
      stream << "          if (*str_index != '\\0' && *str_index != '#')";
      stream << "\n";
      stream << indent_str;
      stream << "            {";
      stream << "\n";
      stream << indent_str;
      stream << "              fprintf";
      stream << "\n";
      stream << indent_str;
      stream << "                (stderr,";
      stream << "\n";
      stream << indent_str;
      stream << "                 \"%s:%s:%d: malformed string in configuration file\\n\",";
      stream << "\n";
      stream << indent_str;
      indent = 17;
      stream << "                 ";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ", filename, line_num);";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "              result = EXIT_FAILURE;";
      stream << "\n";
      stream << indent_str;
      stream << "              break;";
      stream << "\n";
      stream << indent_str;
      stream << "            }";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "    noarg:";
      stream << "\n";
      stream << indent_str;
      stream << "      if (!strcmp(fopt,\"include\")) {";
      stream << "\n";
      stream << indent_str;
      stream << "        if (farg && *farg) {";
      stream << "\n";
      stream << indent_str;
      stream << "          result = _";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_configfile(farg, my_argc);";
      stream << "\n";
      stream << indent_str;
      stream << "        } else {";
      stream << "\n";
      stream << indent_str;
      stream << "          fprintf(stderr, \"%s:%s:%d: include requires a filename argument.\\n\",";
      stream << "\n";
      stream << indent_str;
      indent = 18;
      stream << "                  ";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ", filename, line_num);";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "        continue;";
      stream << "\n";
      stream << indent_str;
      stream << "      }";
      stream << "\n";
      stream << indent_str;
      stream << "      len = strlen(fopt);";
      stream << "\n";
      stream << indent_str;
      stream << "      strcat (my_argv, len > 1 ? \"--\" : \"-\");";
      stream << "\n";
      stream << indent_str;
      stream << "      strcat (my_argv, fopt);";
      stream << "\n";
      stream << indent_str;
      stream << "      if (len > 1 && ((farg && *farg) || equal))";
      stream << "\n";
      stream << indent_str;
      stream << "        strcat (my_argv, \"=\");";
      stream << "\n";
      stream << indent_str;
      stream << "      if (farg && *farg)";
      stream << "\n";
      stream << indent_str;
      stream << "        strcat (my_argv, farg);";
      stream << "\n";
      stream << indent_str;
      stream << "      ++(*my_argc);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));";
      stream << "\n";
      stream << indent_str;
      stream << "      cmd_line_list_tmp->next = cmd_line_list;";
      stream << "\n";
      stream << indent_str;
      stream << "      cmd_line_list = cmd_line_list_tmp;";
      stream << "\n";
      stream << indent_str;
      stream << "      cmd_line_list->string_arg = gengetopt_strdup(my_argv);";
      stream << "\n";
      stream << indent_str;
      stream << "    } /* while */";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (file)";
      stream << "\n";
      stream << indent_str;
      stream << "    fclose(file);";
      stream << "\n";
      stream << indent_str;
      stream << "  return result;";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "int";
      stream << "\n";
      stream << indent_str;
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_configfile (char * const filename,";
      stream << "\n";
      stream << indent_str;
      stream << "                           struct ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << " *args_info,";
      stream << "\n";
      stream << indent_str;
      stream << "                           int override, int initialize, int check_required)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  struct ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_params params;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  params.override = override;";
      stream << "\n";
      stream << indent_str;
      stream << "  params.initialize = initialize;";
      stream << "\n";
      stream << indent_str;
      stream << "  params.check_required = check_required;";
      stream << "\n";
      stream << indent_str;
      stream << "  params.check_ambiguity = 0;";
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "  return ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_config_file (filename, args_info, &params);";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "int";
      stream << "\n";
      stream << indent_str;
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_config_file (char * const filename,";
      stream << "\n";
      stream << indent_str;
      stream << "                           struct ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << " *args_info,";
      stream << "\n";
      stream << indent_str;
      stream << "                           struct ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_params *params)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  int i, result;";
      stream << "\n";
      stream << indent_str;
      stream << "  int my_argc = 1;";
      stream << "\n";
      stream << indent_str;
      stream << "  char **my_argv_arg;";
      stream << "\n";
      stream << indent_str;
      stream << "  char *additional_error;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  /* store the program name */";
      stream << "\n";
      stream << indent_str;
      stream << "  cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));";
      stream << "\n";
      stream << indent_str;
      stream << "  cmd_line_list_tmp->next = cmd_line_list;";
      stream << "\n";
      stream << indent_str;
      stream << "  cmd_line_list = cmd_line_list_tmp;";
      stream << "\n";
      stream << indent_str;
      stream << "  cmd_line_list->string_arg = gengetopt_strdup (";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ");";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  result = _";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_configfile(filename, &my_argc);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (result != EXIT_FAILURE) {";
      stream << "\n";
      stream << indent_str;
      stream << "    my_argv_arg = (char **) malloc((my_argc+1) * sizeof(char *));";
      stream << "\n";
      stream << indent_str;
      stream << "    cmd_line_list_tmp = cmd_line_list;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "    for (i = my_argc - 1; i >= 0; --i) {";
      stream << "\n";
      stream << indent_str;
      stream << "      my_argv_arg[i] = cmd_line_list_tmp->string_arg;";
      stream << "\n";
      stream << indent_str;
      stream << "      cmd_line_list_tmp = cmd_line_list_tmp->next;";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "    my_argv_arg[my_argc] = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "    additional_error = (char *)malloc(strlen(filename) + strlen(ADDITIONAL_ERROR) + 1);";
      stream << "\n";
      stream << indent_str;
      stream << "    strcpy (additional_error, ADDITIONAL_ERROR);";
      stream << "\n";
      stream << indent_str;
      stream << "    strcat (additional_error, filename);";
      stream << "\n";
      stream << indent_str;
      stream << "    result =";
      stream << "\n";
      stream << indent_str;
      indent = 6;
      stream << "      ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_internal (my_argc, my_argv_arg, args_info,";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "                              params,";
      stream << "\n";
      stream << indent_str;
      stream << "                              additional_error);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "    free (additional_error);";
      stream << "\n";
      stream << indent_str;
      stream << "    free (my_argv_arg);";
      stream << "\n";
      stream << indent_str;
      stream << "  }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  free_cmd_list();";
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      generate_string (final_exit, stream, indent + indent_str.length ());
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
    }
  if (generate_string_parser)
    {
      stream << "\n";
      stream << indent_str;
      stream << "static unsigned int";
      stream << "\n";
      stream << indent_str;
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_create_argv(const char *cmdline_, char ***argv_ptr, const char *prog_name)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  char *cmdline, *p;";
      stream << "\n";
      stream << indent_str;
      stream << "  size_t n = 0, j;";
      stream << "\n";
      stream << indent_str;
      stream << "  int i;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  if (prog_name) {";
      stream << "\n";
      stream << indent_str;
      stream << "    cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));";
      stream << "\n";
      stream << indent_str;
      stream << "    cmd_line_list_tmp->next = cmd_line_list;";
      stream << "\n";
      stream << indent_str;
      stream << "    cmd_line_list = cmd_line_list_tmp;";
      stream << "\n";
      stream << indent_str;
      stream << "    cmd_line_list->string_arg = gengetopt_strdup (prog_name);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "    ++n;";
      stream << "\n";
      stream << indent_str;
      stream << "  }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  cmdline = gengetopt_strdup(cmdline_);";
      stream << "\n";
      stream << indent_str;
      stream << "  p = cmdline;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  while (p && strlen(p))";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      j = strcspn(p, \" \\t\");";
      stream << "\n";
      stream << indent_str;
      stream << "      ++n;";
      stream << "\n";
      stream << indent_str;
      stream << "      if (j && j < strlen(p))";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          p[j] = '\\0';";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "          cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));";
      stream << "\n";
      stream << indent_str;
      stream << "          cmd_line_list_tmp->next = cmd_line_list;";
      stream << "\n";
      stream << indent_str;
      stream << "          cmd_line_list = cmd_line_list_tmp;";
      stream << "\n";
      stream << indent_str;
      stream << "          cmd_line_list->string_arg = gengetopt_strdup (p);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "          p += (j+1);";
      stream << "\n";
      stream << indent_str;
      stream << "          p += strspn(p, \" \\t\");";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "      else";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));";
      stream << "\n";
      stream << indent_str;
      stream << "          cmd_line_list_tmp->next = cmd_line_list;";
      stream << "\n";
      stream << indent_str;
      stream << "          cmd_line_list = cmd_line_list_tmp;";
      stream << "\n";
      stream << indent_str;
      stream << "          cmd_line_list->string_arg = gengetopt_strdup (p);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "          break;";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  *argv_ptr = (char **) malloc((n + 1) * sizeof(char *));";
      stream << "\n";
      stream << indent_str;
      stream << "  cmd_line_list_tmp = cmd_line_list;";
      stream << "\n";
      stream << indent_str;
      stream << "  for (i = (n-1); i >= 0; --i)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      (*argv_ptr)[i] = cmd_line_list_tmp->string_arg;";
      stream << "\n";
      stream << indent_str;
      stream << "      cmd_line_list_tmp = cmd_line_list_tmp->next;";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  (*argv_ptr)[n] = NULL;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  free(cmdline);";
      stream << "\n";
      stream << indent_str;
      stream << "  return n;";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "int";
      stream << "\n";
      stream << indent_str;
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_string(const char *cmdline, struct ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << " *args_info, const char *prog_name)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  return ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_string2(cmdline, args_info, prog_name, 0, 1, 1);";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "int";
      stream << "\n";
      stream << indent_str;
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_string2(const char *cmdline, struct ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << " *args_info, const char *prog_name,";
      stream << "\n";
      stream << indent_str;
      stream << "    int override, int initialize, int check_required)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  struct ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_params params;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  params.override = override;";
      stream << "\n";
      stream << indent_str;
      stream << "  params.initialize = initialize;";
      stream << "\n";
      stream << indent_str;
      stream << "  params.check_required = check_required;";
      stream << "\n";
      stream << indent_str;
      stream << "  params.check_ambiguity = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  return ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_string_ext(cmdline, args_info, prog_name, &params);";
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "int";
      stream << "\n";
      stream << indent_str;
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_string_ext(const char *cmdline, struct ";
      generate_string (args_info, stream, indent + indent_str.length ());
      stream << " *args_info, const char *prog_name,";
      stream << "\n";
      stream << indent_str;
      stream << "    struct ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_params *params)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
      stream << "  char **argv_ptr = 0;";
      stream << "\n";
      stream << indent_str;
      stream << "  int result;";
      stream << "\n";
      stream << indent_str;
      stream << "  unsigned int argc;";
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "  argc = ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_create_argv(cmdline, &argv_ptr, prog_name);";
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "  result =";
      stream << "\n";
      stream << indent_str;
      indent = 4;
      stream << "    ";
      generate_string (parser_name, stream, indent + indent_str.length ());
      stream << "_internal (argc, argv_ptr, args_info, params, 0);";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "  if (argv_ptr)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      free (argv_ptr);";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  free_cmd_list();";
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      indent = 2;
      stream << "  ";
      generate_string (final_exit, stream, indent + indent_str.length ());
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "}";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
}
