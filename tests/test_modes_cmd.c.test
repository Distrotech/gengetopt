/*
  File autogenerated by gengetopt 
  generated with the following command:
  ../src/gengetopt --gen-version --input=../../tests/test_modes_cmd.ggo --func-name=test_modes_cmd_parser --file-name=test_modes_cmd --unamed-opt --show-required 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "test_modes_cmd.h"

const char *gengetopt_args_info_purpose = "";

const char *gengetopt_args_info_usage = "Usage: test_modes [OPTIONS]... [FILES]...";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help              Print help and exit",
  "  -V, --version           Print version and exit",
  "\nsome non mode options:",
  "  -N, --no-mode           a generic option not beloging to any mode",
  "      --no-mode2=STRING   another generic option not beloging to any mode",
  "\nsome modes just for testing:",
  "\n Mode: mode1\n  any option of this mode is in contrast with any option of the other mode\n  Notice that this description is quite long so it may spawn many lines...\n  fortunately gengetopt will wrap it for you :-)",
  "  -a, --opta              string a",
  "  -A, --optA[=STRING]     string A (mandatory)",
  "  -M, --optAmul[=STRING]  string M",
  "  -b, --optb              string b",
  "\n Mode: mode 2",
  "      --optc              string c",
  "  -d, --optd              string d (mandatory)",
  "\n Mode: my mode",
  "  -m, --mopt=INT          option of my mode",
    0
};

typedef enum {ARG_NO
  , ARG_STRING
  , ARG_INT
} test_modes_cmd_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
test_modes_cmd_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct test_modes_cmd_parser_params *params, const char *additional_error);

static int
test_modes_cmd_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->no_mode_given = 0 ;
  args_info->no_mode2_given = 0 ;
  args_info->opta_given = 0 ;
  args_info->optA_given = 0 ;
  args_info->optAmul_given = 0 ;
  args_info->optb_given = 0 ;
  args_info->optc_given = 0 ;
  args_info->optd_given = 0 ;
  args_info->mopt_given = 0 ;
  args_info->mode_2_mode_counter = 0 ;
  args_info->mode1_mode_counter = 0 ;
  args_info->my_mode_mode_counter = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->no_mode2_arg = NULL;
  args_info->no_mode2_orig = NULL;
  args_info->optA_arg = NULL;
  args_info->optA_orig = NULL;
  args_info->optAmul_arg = NULL;
  args_info->optAmul_orig = NULL;
  args_info->mopt_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{


  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->no_mode_help = gengetopt_args_info_help[3] ;
  args_info->no_mode2_help = gengetopt_args_info_help[4] ;
  args_info->opta_help = gengetopt_args_info_help[7] ;
  args_info->opta_min = 0;
  args_info->opta_max = 0;
  args_info->optA_help = gengetopt_args_info_help[8] ;
  args_info->optAmul_help = gengetopt_args_info_help[9] ;
  args_info->optAmul_min = 0;
  args_info->optAmul_max = 0;
  args_info->optb_help = gengetopt_args_info_help[10] ;
  args_info->optc_help = gengetopt_args_info_help[12] ;
  args_info->optd_help = gengetopt_args_info_help[13] ;
  args_info->mopt_help = gengetopt_args_info_help[15] ;
  
}

void
test_modes_cmd_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(TEST_MODES_CMD_PARSER_PACKAGE_NAME) ? TEST_MODES_CMD_PARSER_PACKAGE_NAME : TEST_MODES_CMD_PARSER_PACKAGE),
     TEST_MODES_CMD_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  test_modes_cmd_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
test_modes_cmd_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
test_modes_cmd_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = 0;
  args_info->inputs_num = 0;
}

void
test_modes_cmd_parser_params_init(struct test_modes_cmd_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct test_modes_cmd_parser_params *
test_modes_cmd_parser_params_create(void)
{
  struct test_modes_cmd_parser_params *params = 
    (struct test_modes_cmd_parser_params *)malloc(sizeof(struct test_modes_cmd_parser_params));
  test_modes_cmd_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}

/** @brief generic value variable */
union generic_value {
    int int_arg;
    char *string_arg;
    const char *default_string_arg;
};

/** @brief holds temporary values for multiple options */
struct generic_list
{
  union generic_value arg;
  char *orig;
  struct generic_list *next;
};

/**
 * @brief add a node at the head of the list 
 */
static void add_node(struct generic_list **list) {
  struct generic_list *new_node = (struct generic_list *) malloc (sizeof (struct generic_list));
  new_node->next = *list;
  *list = new_node;
  new_node->arg.string_arg = 0;
  new_node->orig = 0;
}


static void
free_multiple_string_field(unsigned int len, char ***arg, char ***orig)
{
  unsigned int i;
  if (*arg) {
    for (i = 0; i < len; ++i)
      {
        free_string_field(&((*arg)[i]));
        free_string_field(&((*orig)[i]));
      }
    free_string_field(&((*arg)[0])); /* free default string */

    free (*arg);
    *arg = 0;
    free (*orig);
    *orig = 0;
  }
}

static void
test_modes_cmd_parser_release (struct gengetopt_args_info *args_info)
{
  unsigned int i;
  free_string_field (&(args_info->no_mode2_arg));
  free_string_field (&(args_info->no_mode2_orig));
  free_string_field (&(args_info->optA_arg));
  free_string_field (&(args_info->optA_orig));
  free_multiple_string_field (args_info->optAmul_given, &(args_info->optAmul_arg), &(args_info->optAmul_orig));
  free_string_field (&(args_info->mopt_orig));
  
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);

  if (args_info->inputs_num)
    free (args_info->inputs);

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}

static void
write_multiple_into_file(FILE *outfile, int len, const char *opt, char **arg, const char *values[])
{
  int i;
  
  for (i = 0; i < len; ++i)
    write_into_file(outfile, opt, (arg ? arg[i] : 0), values);
}

int
test_modes_cmd_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", TEST_MODES_CMD_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->no_mode_given)
    write_into_file(outfile, "no-mode", 0, 0 );
  if (args_info->no_mode2_given)
    write_into_file(outfile, "no-mode2", args_info->no_mode2_orig, 0);
  write_multiple_into_file(outfile, args_info->opta_given, "opta", 0, 0);
  if (args_info->optA_given)
    write_into_file(outfile, "optA", args_info->optA_orig, 0);
  write_multiple_into_file(outfile, args_info->optAmul_given, "optAmul", args_info->optAmul_orig, 0);
  if (args_info->optb_given)
    write_into_file(outfile, "optb", 0, 0 );
  if (args_info->optc_given)
    write_into_file(outfile, "optc", 0, 0 );
  if (args_info->optd_given)
    write_into_file(outfile, "optd", 0, 0 );
  if (args_info->mopt_given)
    write_into_file(outfile, "mopt", args_info->mopt_orig, 0);
  

  i = EXIT_SUCCESS;
  return i;
}

int
test_modes_cmd_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", TEST_MODES_CMD_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = test_modes_cmd_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
test_modes_cmd_parser_free (struct gengetopt_args_info *args_info)
{
  test_modes_cmd_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

static char *
get_multiple_arg_token(const char *arg)
{
  const char *tok;
  char *ret;
  size_t len, num_of_escape, i, j;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');
  num_of_escape = 0;

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
          ++num_of_escape;
        }
      else
        break;
    }

  if (tok)
    len = (size_t)(tok - arg + 1);
  else
    len = strlen (arg) + 1;

  len -= num_of_escape;

  ret = (char *) malloc (len);

  i = 0;
  j = 0;
  while (arg[i] && (j < len-1))
    {
      if (arg[i] == '\\' && 
	  arg[ i + 1 ] && 
	  arg[ i + 1 ] == ',')
        ++i;

      ret[j++] = arg[i++];
    }

  ret[len-1] = '\0';

  return ret;
}

static const char *
get_multiple_arg_token_next(const char *arg)
{
  const char *tok;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
        }
      else
        break;
    }

  if (! tok || strlen(tok) == 1)
    return 0;

  return tok+1;
}

static int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc);

int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc)
{
  int error_occurred = 0;

  if (option_given && (min > 0 || max > 0))
    {
      if (min > 0 && max > 0)
        {
          if (min == max)
            {
              /* specific occurrences */
              if (option_given != (unsigned int) min)
                {
                  fprintf (stderr, "%s: %s option occurrences must be %d\n",
                    prog_name, option_desc, min);
                  error_occurred = 1;
                }
            }
          else if (option_given < (unsigned int) min
                || option_given > (unsigned int) max)
            {
              /* range occurrences */
              fprintf (stderr, "%s: %s option occurrences must be between %d and %d\n",
                prog_name, option_desc, min, max);
              error_occurred = 1;
            }
        }
      else if (min > 0)
        {
          /* at least check */
          if (option_given < min)
            {
              fprintf (stderr, "%s: %s option occurrences must be at least %d\n",
                prog_name, option_desc, min);
              error_occurred = 1;
            }
        }
      else if (max > 0)
        {
          /* at most check */
          if (option_given > max)
            {
              fprintf (stderr, "%s: %s option occurrences must be at most %d\n",
                prog_name, option_desc, max);
              error_occurred = 1;
            }
        }
    }
    
  return error_occurred;
}
int
test_modes_cmd_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return test_modes_cmd_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
test_modes_cmd_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct test_modes_cmd_parser_params *params)
{
  int result;
  result = test_modes_cmd_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      test_modes_cmd_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
test_modes_cmd_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct test_modes_cmd_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = test_modes_cmd_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      test_modes_cmd_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
test_modes_cmd_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (test_modes_cmd_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      test_modes_cmd_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
test_modes_cmd_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (args_info->mode1_mode_counter && check_multiple_option_occurrences(prog_name, args_info->opta_given, args_info->opta_min, args_info->opta_max, "'--opta' ('-a')"))
     error_occurred = 1;
  
  if (args_info->mode1_mode_counter && ! args_info->optA_given)
    {
      fprintf (stderr, "%s: '--optA' ('-A') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (args_info->mode1_mode_counter && check_multiple_option_occurrences(prog_name, args_info->optAmul_given, args_info->optAmul_min, args_info->optAmul_max, "'--optAmul' ('-M')"))
     error_occurred = 1;
  
  if (args_info->mode_2_mode_counter && ! args_info->optd_given)
    {
      fprintf (stderr, "%s: '--optd' ('-d') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  
  /* checks for dependences among options */

  return error_occurred;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see test_modes_cmd_parser_params.check_ambiguity
 * @param override @see test_modes_cmd_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               test_modes_cmd_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}

/**
 * @brief store information about a multiple option in a temporary list
 * @param list where to (temporarily) store multiple options
 */
static
int update_multiple_arg_temp(struct generic_list **list,
               unsigned int *prev_given, const char *val,
               const char *possible_values[], const char *default_value,
               test_modes_cmd_parser_arg_type arg_type,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  /* store single arguments */
  char *multi_token;
  const char *multi_next;

  if (arg_type == ARG_NO) {
    (*prev_given)++;
    return 0; /* OK */
  }

  multi_token = get_multiple_arg_token(val);
  multi_next = get_multiple_arg_token_next (val);

  while (1)
    {
      add_node (list);
      if (update_arg((void *)&((*list)->arg), &((*list)->orig), 0,
          prev_given, multi_token, possible_values, default_value, 
          arg_type, 0, 1, 1, 1, long_opt, short_opt, additional_error)) {
        if (multi_token) free(multi_token);
        return 1; /* failure */
      }

      if (multi_next)
        {
          multi_token = get_multiple_arg_token(multi_next);
          multi_next = get_multiple_arg_token_next (multi_next);
        }
      else
        break;
    }

  return 0; /* OK */
}

/**
 * @brief free the passed list (including possible string argument)
 */
static
void free_list(struct generic_list *list, short string_arg)
{
  if (list) {
    struct generic_list *tmp;
    while (list)
      {
        tmp = list;
        if (string_arg && list->arg.string_arg)
          free (list->arg.string_arg);
        if (list->orig)
          free (list->orig);
        list = list->next;
        free (tmp);
      }
  }
}

/**
 * @brief updates a multiple option starting from the passed list
 */
static
void update_multiple_arg(void *field, char ***orig_field,
               unsigned int field_given, unsigned int prev_given, union generic_value *default_value,
               test_modes_cmd_parser_arg_type arg_type,
               struct generic_list *list)
{
  int i;
  struct generic_list *tmp;

  if (prev_given && list) {
    *orig_field = (char **) realloc (*orig_field, (field_given + prev_given) * sizeof (char *));

    switch(arg_type) {
    case ARG_INT:
      *((int **)field) = (int *)realloc (*((int **)field), (field_given + prev_given) * sizeof (int)); break;
    case ARG_STRING:
      *((char ***)field) = (char **)realloc (*((char ***)field), (field_given + prev_given) * sizeof (char *)); break;
    default:
      break;
    };
    
    for (i = (prev_given - 1); i >= 0; --i)
      {
        tmp = list;
        
        switch(arg_type) {
        case ARG_INT:
          (*((int **)field))[i + field_given] = tmp->arg.int_arg; break;
        case ARG_STRING:
          (*((char ***)field))[i + field_given] = tmp->arg.string_arg; break;
        default:
          break;
        }        
        (*orig_field) [i + field_given] = list->orig;
        list = list->next;
        free (tmp);
      }
  } else { /* set the default value */
    if (default_value && ! field_given) {
      switch(arg_type) {
      case ARG_INT:
        if (! *((int **)field)) {
          *((int **)field) = (int *)malloc (sizeof (int));
          (*((int **)field))[0] = default_value->int_arg; 
        }
        break;
      case ARG_STRING:
        if (! *((char ***)field)) {
          *((char ***)field) = (char **)malloc (sizeof (char *));
          (*((char ***)field))[0] = gengetopt_strdup(default_value->string_arg);
        }
        break;
      default: break;
      }
      if (!(*orig_field)) {
        *orig_field = (char **) malloc (sizeof (char *));
        (*orig_field)[0] = 0;
      }
    }
  }
}

static int check_modes(
  int given1[], const char *options1[],
                       int given2[], const char *options2[])
{
  int i = 0, j = 0, errors = 0;
  
  while (given1[i] >= 0) {
    if (given1[i]) {
      while (given2[j] >= 0) {
        if (given2[j]) {
          ++errors;
          fprintf(stderr, "%s: option %s conflicts with option %s\n",
                  package_name, options1[i], options2[j]);
        }
        ++j;
      }
    }
    ++i;
  }
  
  return errors;
}

int
test_modes_cmd_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct test_modes_cmd_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  struct generic_list * optAmul_list = NULL;
  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    test_modes_cmd_parser_init (args_info);

  test_modes_cmd_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "no-mode",	0, NULL, 'N' },
        { "no-mode2",	1, NULL, 0 },
        { "opta",	0, NULL, 'a' },
        { "optA",	2, NULL, 'A' },
        { "optAmul",	2, NULL, 'M' },
        { "optb",	0, NULL, 'b' },
        { "optc",	0, NULL, 0 },
        { "optd",	0, NULL, 'd' },
        { "mopt",	1, NULL, 'm' },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hVNaA::M::bdm:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          test_modes_cmd_parser_print_help ();
          test_modes_cmd_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          test_modes_cmd_parser_print_version ();
          test_modes_cmd_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'N':	/* a generic option not beloging to any mode.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->no_mode_given),
              &(local_args_info.no_mode_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "no-mode", 'N',
              additional_error))
            goto failure;
        
          break;
        case 'a':	/* string a.  */
          args_info->mode1_mode_counter += 1;
        
          local_args_info.opta_given++;
        
          break;
        case 'A':	/* string A.  */
          args_info->mode1_mode_counter += 1;
        
        
          if (update_arg( (void *)&(args_info->optA_arg), 
               &(args_info->optA_orig), &(args_info->optA_given),
              &(local_args_info.optA_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "optA", 'A',
              additional_error))
            goto failure;
        
          break;
        case 'M':	/* string M.  */
          args_info->mode1_mode_counter += 1;
        
          if (update_multiple_arg_temp(&optAmul_list, 
              &(local_args_info.optAmul_given), optarg, 0, 0, ARG_STRING,
              "optAmul", 'M',
              additional_error))
            goto failure;
        
          break;
        case 'b':	/* string b.  */
          args_info->mode1_mode_counter += 1;
        
        
          if (update_arg( 0 , 
               0 , &(args_info->optb_given),
              &(local_args_info.optb_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "optb", 'b',
              additional_error))
            goto failure;
        
          break;
        case 'd':	/* string d.  */
          args_info->mode_2_mode_counter += 1;
        
        
          if (update_arg( 0 , 
               0 , &(args_info->optd_given),
              &(local_args_info.optd_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "optd", 'd',
              additional_error))
            goto failure;
        
          break;
        case 'm':	/* option of my mode.  */
          args_info->my_mode_mode_counter += 1;
        
        
          if (update_arg( (void *)&(args_info->mopt_arg), 
               &(args_info->mopt_orig), &(args_info->mopt_given),
              &(local_args_info.mopt_given), optarg, 0, 0, ARG_INT,
              check_ambiguity, override, 0, 0,
              "mopt", 'm',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          /* another generic option not beloging to any mode.  */
          if (strcmp (long_options[option_index].name, "no-mode2") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->no_mode2_arg), 
                 &(args_info->no_mode2_orig), &(args_info->no_mode2_given),
                &(local_args_info.no_mode2_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "no-mode2", '-',
                additional_error))
              goto failure;
          
          }
          /* string c.  */
          else if (strcmp (long_options[option_index].name, "optc") == 0)
          {
            args_info->mode_2_mode_counter += 1;
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->optc_given),
                &(local_args_info.optc_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "optc", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", TEST_MODES_CMD_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */


  update_multiple_arg((void *)&(args_info->optAmul_arg),
    &(args_info->optAmul_orig), args_info->optAmul_given,
    local_args_info.optAmul_given, 0,
    ARG_STRING, optAmul_list);

  args_info->opta_given += local_args_info.opta_given;
  local_args_info.opta_given = 0;
  args_info->optAmul_given += local_args_info.optAmul_given;
  local_args_info.optAmul_given = 0;
  
  if (args_info->mode_2_mode_counter && args_info->mode1_mode_counter) {
    int mode_2_given[] = {args_info->optc_given, args_info->optd_given,  -1};
    const char *mode_2_desc[] = {"--optc", "--optd",  0};
    int mode1_given[] = {args_info->opta_given, args_info->optA_given, args_info->optAmul_given, args_info->optb_given,  -1};
    const char *mode1_desc[] = {"--opta", "--optA", "--optAmul", "--optb",  0};
    error_occurred += check_modes(mode_2_given, mode_2_desc, mode1_given, mode1_desc);
  }
  if (args_info->mode_2_mode_counter && args_info->my_mode_mode_counter) {
    int mode_2_given[] = {args_info->optc_given, args_info->optd_given,  -1};
    const char *mode_2_desc[] = {"--optc", "--optd",  0};
    int my_mode_given[] = {args_info->mopt_given,  -1};
    const char *my_mode_desc[] = {"--mopt",  0};
    error_occurred += check_modes(mode_2_given, mode_2_desc, my_mode_given, my_mode_desc);
  }
  if (args_info->mode1_mode_counter && args_info->my_mode_mode_counter) {
    int mode1_given[] = {args_info->opta_given, args_info->optA_given, args_info->optAmul_given, args_info->optb_given,  -1};
    const char *mode1_desc[] = {"--opta", "--optA", "--optAmul", "--optb",  0};
    int my_mode_given[] = {args_info->mopt_given,  -1};
    const char *my_mode_desc[] = {"--mopt",  0};
    error_occurred += check_modes(mode1_given, mode1_desc, my_mode_given, my_mode_desc);
  }
  
  if (check_required)
    {
      error_occurred += test_modes_cmd_parser_required2 (args_info, argv[0], additional_error);
    }

  test_modes_cmd_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */

      i = optind;
      while (i < argc)
        if (argv[i++] == argv[0]) {
          found_prog_name = 1;
          break;
        }
      i = 0;

      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        if (argv[optind++] != argv[0])
          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;
    }

  return 0;

failure:
  free_list (optAmul_list, 1 );
  
  test_modes_cmd_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
