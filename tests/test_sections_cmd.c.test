/*
  File autogenerated by gengetopt 
  generated with the following command:
  ../src/gengetopt --gen-version --input=test_sections_cmd.ggo --func-name=test_sections_cmd_parser --file-name=test_sections_cmd --unamed-opt --show-required 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"

#include "test_sections_cmd.h"

const char *gengetopt_args_info_purpose = "";

const char *gengetopt_args_info_usage = "Usage: test_sections [OPTIONS]... [FILES]...";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help                   Print help and exit",
  "  -V, --version                Print version and exit",
  "  -s, --string=STRING          string option",
  "  -i, --int=INT                int option",
  "\nFirst section.  This \"section\" definition has no description, since the \ndescription is in the definition itself, that is wrapped too:",
  "  -S, --short=SHORT            short option",
  "  -l, --long=LONG              long option",
  "  -f, --float=FLOAT            float option",
  "  -d, --double=DOUBLE          double option",
  "  -D, --longdouble=LONGDOUBLE  longdouble option",
  "\nSecond section:",
  "  The following options belong to the second section\n  by the way this second section also has this neat description, and it is \n  quite long so it should require some kind of line wrapping, but don't worry: \n  gengetopt will wrap it for you! ;-)",
  "  -L, --longlong=LONGLONG      longlong option",
  "  -F, --flag                   flag option  (default=on)",
  "  -u, --function               function option",
  "\nLast section:",
  "      --no-short               no short option",
  "  -r, --required=STRING        required option (mandatory)",
    0
};

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
test_sections_cmd_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error);

static int
test_sections_cmd_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->string_given = 0 ;
  args_info->int_given = 0 ;
  args_info->short_given = 0 ;
  args_info->long_given = 0 ;
  args_info->float_given = 0 ;
  args_info->double_given = 0 ;
  args_info->longdouble_given = 0 ;
  args_info->longlong_given = 0 ;
  args_info->flag_given = 0 ;
  args_info->function_given = 0 ;
  args_info->no_short_given = 0 ;
  args_info->required_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  args_info->string_arg = NULL;
  args_info->string_orig = NULL;
  args_info->int_orig = NULL;
  args_info->short_orig = NULL;
  args_info->long_orig = NULL;
  args_info->float_orig = NULL;
  args_info->double_orig = NULL;
  args_info->longdouble_orig = NULL;
  args_info->longlong_orig = NULL;
  args_info->flag_flag = 1;
  args_info->required_arg = NULL;
  args_info->required_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{
  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->string_help = gengetopt_args_info_help[2] ;
  args_info->int_help = gengetopt_args_info_help[3] ;
  args_info->short_help = gengetopt_args_info_help[5] ;
  args_info->long_help = gengetopt_args_info_help[6] ;
  args_info->float_help = gengetopt_args_info_help[7] ;
  args_info->double_help = gengetopt_args_info_help[8] ;
  args_info->longdouble_help = gengetopt_args_info_help[9] ;
  args_info->longlong_help = gengetopt_args_info_help[12] ;
  args_info->flag_help = gengetopt_args_info_help[13] ;
  args_info->function_help = gengetopt_args_info_help[14] ;
  args_info->no_short_help = gengetopt_args_info_help[16] ;
  args_info->required_help = gengetopt_args_info_help[17] ;
  
}

void
test_sections_cmd_parser_print_version (void)
{
  printf ("%s %s\n", TEST_SECTIONS_CMD_PARSER_PACKAGE, TEST_SECTIONS_CMD_PARSER_VERSION);
}

void
test_sections_cmd_parser_print_help (void)
{
  int i = 0;
  test_sections_cmd_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  printf("\n%s\n\n", gengetopt_args_info_usage);

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n", gengetopt_args_info_description);

  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
test_sections_cmd_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = NULL;
  args_info->inputs_num = 0;
}

static void
test_sections_cmd_parser_release (struct gengetopt_args_info *args_info)
{
  
  unsigned int i;
  if (args_info->string_arg)
    {
      free (args_info->string_arg); /* free previous argument */
      args_info->string_arg = 0;
    }
  if (args_info->string_orig)
    {
      free (args_info->string_orig); /* free previous argument */
      args_info->string_orig = 0;
    }
  if (args_info->int_orig)
    {
      free (args_info->int_orig); /* free previous argument */
      args_info->int_orig = 0;
    }
  if (args_info->short_orig)
    {
      free (args_info->short_orig); /* free previous argument */
      args_info->short_orig = 0;
    }
  if (args_info->long_orig)
    {
      free (args_info->long_orig); /* free previous argument */
      args_info->long_orig = 0;
    }
  if (args_info->float_orig)
    {
      free (args_info->float_orig); /* free previous argument */
      args_info->float_orig = 0;
    }
  if (args_info->double_orig)
    {
      free (args_info->double_orig); /* free previous argument */
      args_info->double_orig = 0;
    }
  if (args_info->longdouble_orig)
    {
      free (args_info->longdouble_orig); /* free previous argument */
      args_info->longdouble_orig = 0;
    }
  if (args_info->longlong_orig)
    {
      free (args_info->longlong_orig); /* free previous argument */
      args_info->longlong_orig = 0;
    }
  if (args_info->required_arg)
    {
      free (args_info->required_arg); /* free previous argument */
      args_info->required_arg = 0;
    }
  if (args_info->required_orig)
    {
      free (args_info->required_orig); /* free previous argument */
      args_info->required_orig = 0;
    }
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);
  
  if (args_info->inputs_num)
    free (args_info->inputs);
  
  clear_given (args_info);
}

int
test_sections_cmd_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", TEST_SECTIONS_CMD_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  if (args_info->help_given) {
    fprintf(outfile, "%s\n", "help");
  }
  if (args_info->version_given) {
    fprintf(outfile, "%s\n", "version");
  }
  if (args_info->string_given) {
    if (args_info->string_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "string", args_info->string_orig);
    } else {
      fprintf(outfile, "%s\n", "string");
    }
  }
  if (args_info->int_given) {
    if (args_info->int_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "int", args_info->int_orig);
    } else {
      fprintf(outfile, "%s\n", "int");
    }
  }
  if (args_info->short_given) {
    if (args_info->short_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "short", args_info->short_orig);
    } else {
      fprintf(outfile, "%s\n", "short");
    }
  }
  if (args_info->long_given) {
    if (args_info->long_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "long", args_info->long_orig);
    } else {
      fprintf(outfile, "%s\n", "long");
    }
  }
  if (args_info->float_given) {
    if (args_info->float_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "float", args_info->float_orig);
    } else {
      fprintf(outfile, "%s\n", "float");
    }
  }
  if (args_info->double_given) {
    if (args_info->double_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "double", args_info->double_orig);
    } else {
      fprintf(outfile, "%s\n", "double");
    }
  }
  if (args_info->longdouble_given) {
    if (args_info->longdouble_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "longdouble", args_info->longdouble_orig);
    } else {
      fprintf(outfile, "%s\n", "longdouble");
    }
  }
  if (args_info->longlong_given) {
    if (args_info->longlong_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "longlong", args_info->longlong_orig);
    } else {
      fprintf(outfile, "%s\n", "longlong");
    }
  }
  if (args_info->flag_given) {
    fprintf(outfile, "%s\n", "flag");
  }
  if (args_info->function_given) {
    fprintf(outfile, "%s\n", "function");
  }
  if (args_info->no_short_given) {
    fprintf(outfile, "%s\n", "no-short");
  }
  if (args_info->required_given) {
    if (args_info->required_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "required", args_info->required_orig);
    } else {
      fprintf(outfile, "%s\n", "required");
    }
  }
  
  fclose (outfile);

  i = EXIT_SUCCESS;
  return i;
}

void
test_sections_cmd_parser_free (struct gengetopt_args_info *args_info)
{
  test_sections_cmd_parser_release (args_info);
}


/* gengetopt_strdup() */
/* strdup.c replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = NULL;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
test_sections_cmd_parser (int argc, char * const *argv, struct gengetopt_args_info *args_info)
{
  return test_sections_cmd_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
test_sections_cmd_parser2 (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;

  result = test_sections_cmd_parser_internal (argc, argv, args_info, override, initialize, check_required, NULL);

  if (result == EXIT_FAILURE)
    {
      test_sections_cmd_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
test_sections_cmd_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (test_sections_cmd_parser_required2(args_info, prog_name, NULL) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      test_sections_cmd_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
test_sections_cmd_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error = 0;

  /* checks for required options */
  if (! args_info->required_given)
    {
      fprintf (stderr, "%s: '--required' ('-r') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  
  /* checks for dependences among options */

  return error;
}

int
test_sections_cmd_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct gengetopt_args_info local_args_info;

  if (initialize)
    test_sections_cmd_parser_init (args_info);

  test_sections_cmd_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = 1;
  optopt = '?';

  while (1)
    {
      int option_index = 0;
      char *stop_char;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "string",	1, NULL, 's' },
        { "int",	1, NULL, 'i' },
        { "short",	1, NULL, 'S' },
        { "long",	1, NULL, 'l' },
        { "float",	1, NULL, 'f' },
        { "double",	1, NULL, 'd' },
        { "longdouble",	1, NULL, 'D' },
        { "longlong",	1, NULL, 'L' },
        { "flag",	0, NULL, 'F' },
        { "function",	0, NULL, 'u' },
        { "no-short",	0, NULL, 0 },
        { "required",	1, NULL, 'r' },
        { NULL,	0, NULL, 0 }
      };

      stop_char = 0;
      c = getopt_long (argc, argv, "hVs:i:S:l:f:d:D:L:Fur:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          test_sections_cmd_parser_print_help ();
          test_sections_cmd_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          test_sections_cmd_parser_print_version ();
          test_sections_cmd_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 's':	/* string option.  */
          if (local_args_info.string_given)
            {
              fprintf (stderr, "%s: `--string' (`-s') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->string_given && ! override)
            continue;
          local_args_info.string_given = 1;
          args_info->string_given = 1;
          if (args_info->string_arg)
            free (args_info->string_arg); /* free previous string */
          args_info->string_arg = gengetopt_strdup (optarg);
          if (args_info->string_orig)
            free (args_info->string_orig); /* free previous string */
          args_info->string_orig = gengetopt_strdup (optarg);
          break;

        case 'i':	/* int option.  */
          if (local_args_info.int_given)
            {
              fprintf (stderr, "%s: `--int' (`-i') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->int_given && ! override)
            continue;
          local_args_info.int_given = 1;
          args_info->int_given = 1;
          args_info->int_arg = strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->int_orig)
            free (args_info->int_orig); /* free previous string */
          args_info->int_orig = gengetopt_strdup (optarg);
          break;

        case 'S':	/* short option.  */
          if (local_args_info.short_given)
            {
              fprintf (stderr, "%s: `--short' (`-S') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->short_given && ! override)
            continue;
          local_args_info.short_given = 1;
          args_info->short_given = 1;
          args_info->short_arg = (short)strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->short_orig)
            free (args_info->short_orig); /* free previous string */
          args_info->short_orig = gengetopt_strdup (optarg);
          break;

        case 'l':	/* long option.  */
          if (local_args_info.long_given)
            {
              fprintf (stderr, "%s: `--long' (`-l') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->long_given && ! override)
            continue;
          local_args_info.long_given = 1;
          args_info->long_given = 1;
          args_info->long_arg = strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->long_orig)
            free (args_info->long_orig); /* free previous string */
          args_info->long_orig = gengetopt_strdup (optarg);
          break;

        case 'f':	/* float option.  */
          if (local_args_info.float_given)
            {
              fprintf (stderr, "%s: `--float' (`-f') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->float_given && ! override)
            continue;
          local_args_info.float_given = 1;
          args_info->float_given = 1;
          args_info->float_arg = (float)strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->float_orig)
            free (args_info->float_orig); /* free previous string */
          args_info->float_orig = gengetopt_strdup (optarg);
          break;

        case 'd':	/* double option.  */
          if (local_args_info.double_given)
            {
              fprintf (stderr, "%s: `--double' (`-d') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->double_given && ! override)
            continue;
          local_args_info.double_given = 1;
          args_info->double_given = 1;
          args_info->double_arg = strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->double_orig)
            free (args_info->double_orig); /* free previous string */
          args_info->double_orig = gengetopt_strdup (optarg);
          break;

        case 'D':	/* longdouble option.  */
          if (local_args_info.longdouble_given)
            {
              fprintf (stderr, "%s: `--longdouble' (`-D') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->longdouble_given && ! override)
            continue;
          local_args_info.longdouble_given = 1;
          args_info->longdouble_given = 1;
          args_info->longdouble_arg = (long double)strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->longdouble_orig)
            free (args_info->longdouble_orig); /* free previous string */
          args_info->longdouble_orig = gengetopt_strdup (optarg);
          break;

        case 'L':	/* longlong option.  */
          if (local_args_info.longlong_given)
            {
              fprintf (stderr, "%s: `--longlong' (`-L') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->longlong_given && ! override)
            continue;
          local_args_info.longlong_given = 1;
          args_info->longlong_given = 1;
          #ifdef HAVE_LONG_LONG
          args_info->longlong_arg = (long long int) strtol (optarg, &stop_char, 0);
          #else
          args_info->longlong_arg = (long) strtol (optarg, &stop_char, 0);
          #endif
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->longlong_orig)
            free (args_info->longlong_orig); /* free previous string */
          args_info->longlong_orig = gengetopt_strdup (optarg);
          break;

        case 'F':	/* flag option.  */
          if (local_args_info.flag_given)
            {
              fprintf (stderr, "%s: `--flag' (`-F') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->flag_given && ! override)
            continue;
          local_args_info.flag_given = 1;
          args_info->flag_given = 1;
          args_info->flag_flag = !(args_info->flag_flag);
          break;

        case 'u':	/* function option.  */
          if (local_args_info.function_given)
            {
              fprintf (stderr, "%s: `--function' (`-u') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->function_given && ! override)
            continue;
          local_args_info.function_given = 1;
          args_info->function_given = 1;
          break;

        case 'r':	/* required option.  */
          if (local_args_info.required_given)
            {
              fprintf (stderr, "%s: `--required' (`-r') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->required_given && ! override)
            continue;
          local_args_info.required_given = 1;
          args_info->required_given = 1;
          if (args_info->required_arg)
            free (args_info->required_arg); /* free previous string */
          args_info->required_arg = gengetopt_strdup (optarg);
          if (args_info->required_orig)
            free (args_info->required_orig); /* free previous string */
          args_info->required_orig = gengetopt_strdup (optarg);
          break;


        case 0:	/* Long option with no short option */
          /* no short option.  */
          if (strcmp (long_options[option_index].name, "no-short") == 0)
          {
            if (local_args_info.no_short_given)
              {
                fprintf (stderr, "%s: `--no-short' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->no_short_given && ! override)
              continue;
            local_args_info.no_short_given = 1;
            args_info->no_short_given = 1;
            break;
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", TEST_SECTIONS_CMD_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error += test_sections_cmd_parser_required2 (args_info, argv[0], additional_error);
    }

  test_sections_cmd_parser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */

      i = optind;
      while (i < argc)
        if (argv[i++] == argv[0]) {
          found_prog_name = 1;
          break;
        }
      i = 0;

      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        if (argv[optind++] != argv[0])
          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;
    }

  return 0;

failure:
  
  test_sections_cmd_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
